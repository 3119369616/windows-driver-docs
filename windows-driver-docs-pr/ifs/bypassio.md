---
title: BypassIO
description: About Bypass I/O
keywords:
- filter drivers WDK file system , bypass I/O
ms.date: 06/29/2021
prerelease: true
ms.localizationpriority: medium
---

# BypassIO

## About BypassIO

Starting in Windows 11, BypassIO was added as an optimized I/O path for reading from files. The goal of this path is reduce the CPU overhead of doing reads, helping to meet the I/O demands of loading and running next-generation games on Windows. BypassIO is a part of the infrastructure to support DirectStorage on Windows.  

It is important that all minifilters implement support for BypassIO. Without filter support, game performance will be degraded, resulting in a poor gaming experience for end users.

There will be broader application uses beyond gaming in future Windows releases.

BypassIO is a per handle concept. When BypassIO is requested, it is requested for an explicit file handle. BypassIO has no impact on other handles for that file.

**FSCTL_MANAGE_BYPASS_IO** and an equivalent **IOCTL_STORAGE_MANAGE_BYPASS_IO** were added as a part of this infrastructure. Minifilters process **FSCTL_MANAGE_BYPASS_IO**, while **IOCTL_STORAGE_MANAGE_BYPASS_IO** is sent by file systems to the volume/storage stacks. These control codes are designed to be diagnosable: they both return the identity of the driver that failed the BypassIO request, and the reason for vetoing it.

## Scope of BypassIO support

Starting in Windows 11, BypassIO is supported as follows:

* On Windows client systems only. Server system support will be added in a future release.

* On NVMe storage devices only. Support for other storage technologies will be added in a future release.

* On the NTFS file system only. Support for other file systems will be added in a future release.

* Only non-cached reads are supported. Support for non-cached writes will be added in a future release.

* Only supported on files (not supported on directory or volume handles).

## How BypassIO works

When [**NtReadFile**](/windows-hardware/drivers/ddi/ntifs/nf-ntifs-ntreadfile) is called on a BypassIO-enabled **FileHandle**, instead of flowing through the traditional I/O stack, the operations flow directly from the I/O manager to the (NTFS) file system and then to the (NVMe) storage driver (no IRP is issued):

* All file system filters are skipped
* All volume and storage stack filters and drivers are skipped

## DDIs changes and additions for BypassIO



The following DDIs were added to provide BypassIO support:

* **IOCTL_STORAGE_MANAGE_BYPASS_IO**, which is generated by the file system

The following DDIs were changed to provide BypassIO support:



## FSCTL_MANAGE_BYPASS_IO implementation details

There are several operation supported by FSCTL_MANAGE_BYPASS_IO:

typedef enum _FS_BPIO_OPERATIONS {
  ENABLE
DISABLE
QUERY
VOLUME_STACK_PAUSE
VOLUME_STACK_RESUME
STREAM_PAUSE
STREAM_RESUME
} FS_BPIO_OPERATIONS

FS_BPIO_INPUT structure:
{
  FS_BPIO_OPERATIONS Operation;
  FS_BPIO_INFLAGS InFlags;
} FS_BPIO_INPUT

FS_BPIO_OUTPUT structure:
{
  FS_BPIO_OPERATIONS Operation;
  FS_BPIO_OUTFLAGS OutFlags;
  union {
    FS_BPIO_RESULTS Enable;
    FS_BPIO_RESULTS Query;
    FS_BPIO_RESULTS VolumeStackResume;
    FS_BPIO_RESULTS StreamResume;
  }
} FS_BPIO_OUTPUT

struct FS_BPIO_RESULTS {
  NTSTATUS OpStatus;
  USHORT FailingDriverNameLen; // name of the driver failing the operation
  WCHAR FailingDriverName[32];
  USHORT FailureReasonLen;
  WCHAR FailureReason[128];
} FS_BPIO_RESULTS


### Enable Operation

The API that starts it all
FS_BPIO_OP_ENABLE is a request to enable BypassIO for a given FileObject.

  * This is a per file open concept; that is this request only impacts the file object that is associated with the request to enable BypassIO
  * This does not change the behavior of other opens on the same file or stream

NOTE
All filters in the file system stack have the opportunity to veto the request. If your filter vetos the request, you must provide the following information in the RESULTS section of OUTPUT structure:

* Your driver name
* An NTSTATUS code describing why you vetoed the Enable request
* A unique, descriptive string providing more details on why you vetoed the request. This string is for diagnostic purposes and needs to be searchable, so do not localize it.

FltVetoBypassIo - new filter manager support API
Helper routine when a filter needs to block a request. Filter can call this routine to send the veto information back.

If multiple requests to the same FileObject are sent, only the first one is meaningful (all subsequent requests are ignored)

The file system will automatically veto for the following types of files:

* Directories (alternate data streams on a directory can use BypassIO)
* Volumes (DASD opens)
* NTFS compressed files
* NTFS encryted files
* Sparse files
* Paging files
* All files on DAX volumes

Most filters will not need to maintain state that BypassIO has been enabled on a specific stream. Instead, this information can be queried:

Added a BypassIoOpenCount field to the FSRTL_ADVANCED_FCB_HEADER structure that maintains a count of unique FileObjects on a stream that currently have BypassIO enabled.
NOTE: the addition of this field increases the structure size. The structure version to use starting in WIN_COBALT is FSRTL_FCB_HEADER_V4.

Added starting in WIN_COBALT:
FsRtlGetBypassIoOpenCount(FileObject)
Returns a count of how many opens there are for a given stream, that is it returns the current value of FSRTL_ADVANCED_FCB_HEADER.BypassIoOpenCount, or zero if the FSRTL_ADVANCED_FCB_HEADER structure associated with the given FileObject does not have a BypassIoOpenCount

#### Enable example

When an encryption filter receives a FS_BPIO_OP_ENABLE operation on a file that is already encrypted, it should call FltVetoBypassIO to veto the BypassIO operation and return an appropriate status and diagnostic message, such as:
  OpStatus = STATUS_NOT_SUPPORTED_WITH_ENCRYPTION
  FailureReason = "Encrypted file not supported"

When an encryption filter receives a FS_BPIO_OP_ENABLE operation on a file that is not currently encrypted, it should allow BypassIO. If a later request is made to encrypt this file, the filter can use the FS_BPIO_OP_STREAM_PAUSE operation to disable BypassIO.

### Disable Operation: FS_BPIO_OP_DISABLE

FS_BPIO_OP_DISABLE is a request to turn off BypassIO for the given FileObject. This request can come from user or kernel mode.  This informs filters and file systems that BypassIO is being disabled on this file. It allows a driver to cleanup any associated BypassIO state.

If a driver has previously allowed BypassIO to be enabled on this file and now needs to turn off BypassIO support for a file (a good example is an encryption driver wanting to encrypt this file.  They should send the FS_BPIO_OP_DISABLE FSCTL to the top of the file system stack using the associated handle.

If a driver receives FS_BPIO_OP_DISABLE but does not currently have BypassIO enabled, it should ignore the request.  If sent on a file that currently does not have BypassIO enabled, it should be ignored.

This operation should not be failed.

### Query operation: FS_BPIO_OP_QUERY

The FS_BPIO_OP_QUERY operation is an informational request that is used to determine whether BypassIO can be enabled on a given FileObject without enabling it. This request can come from user or kernel mode. Filters should process this request the same as an ENABLE operation, vetoing as appropriate and filling in the same diagnostic information in the appropriate fields in the FS_BPIO_OUTPUT structure. The only difference is that the driver does not enter the ENABLE state.

This operation can be sent on directory and volume handles (an FS_BPIO_OP_ENABLE request cannot be sent on directory or volume handles).

#### Query Example

When an encryption filter receives a FS_BPIO_OP_QUERY operation on a file that is already encrypted, it should call FltVetoBypassIO to veto the BypassIO operation and return an appropriate status and diagnostic message, such as:
  OpStatus = STATUS_NOT_SUPPORTED_WITH_ENCRYPTION
  FailureReason = "Encrypted file not supported"

When an encryption filter receives an FS_BPIO_OP_QUERY operation on a file that is not currently encrypted, it should succeed the query request.

### Stream pause operation

A filter can send an FS_BPIO_OP_STREAM_PAUSE operation to pause BypassIO on a stream. Specifically, if a filter previously allowed BypassIO to be enabled on a stream and subsequently needs to stop BypassIO (due to an external request such as a request to encrypt a file or directory), it can:

* Send a FS_BPIO_OP_STREAM_PAUSE down the filter stack to tell the file system to stop doing BypassIO on the given stream. Do not send this operation to the top of the stack.
* Before returning, the file system will pause all BypassIO handles open on the stream and drain all active BypassIO operations on the stream. This ensures that, on return, the filter can perform the file operation that it needs to do.
* This operation can sent multiple times to the same stream. The file system will ignore this operation if it is sent on a stream that is not currently BypassIO-enabled.

NOTE: If you do a stream pause operation, BypassIO will continue on the volume and storage stacks.

#### Stream pause example

Say an encryption filter allowed BypassIO to be enabled on a stream that was not then encrypted, and has now received a request to encrypt this stream.

Before proceeding, the encryption filter should call **FsRtlGetBypassIoOpenCount** to determine whether BypassIO is active on this stream. If yes, the encryption filter sends a **FS_BPIO_OP_STREAM_PAUSE** operation asking that BypassIO be disabled. Upon successful return, BypassIO is disabled and drained, so the filter can safely perform the encryption request. To eliminate possible race conditions, the filter must veto all future **FS_BPIO_OP_ENABLE** and **FS_BPIO_OP_QUERY** requests on this now encrypted stream.

### FS_BPIO_OP_STREAM_RESUME operation

When the scenario that caused the filter to send a **FS_BPIO_OP_STREAM_PAUSE** operation no longer exists, the filter sends a **FS_BPIO_OP_STREAM_RESUME** operation to the file system to resume BypassIO processing of a given stream.

If this operation is sent when BypassIO is not currently enabled or paused, it is ignored.

Pause and resume are not reference counted. Rather, on a resume, the file system issues a **FS_BPIO_OP_QUERY** request to the top of the file system stack to figure out if any remaining filters are still blocking. The file system will resume BypassIO only if all filters in the stack are not blocking BypassIO.

#### Stream resume example

The file that was previously encrypted after call to **FS_BPIO_OP_STREAM_PAUSE** is no longer encrypted, so filter should send **FS_BPIO_OP_STREAM_RESUME** operation to allow BypassIO to resume on that stream.

## Impacts of other operations on BypassIO-enabled handles

Enabling BypassIO on a handle doesn't impact other handles. However, other operations on a BypassIO-enabled handle do impact the use of BypassIO, such as the following:

* If you have a BypassIO-enabled handle on which BypassIO is enabled and functioning, and someone opens that file handle to perform cached or memory-mapped I/O on that handle, the system will temporarily disable BypassIO on that thread, and instead use the traditional I/O path, to guarantee that stale data does not occur. The system continues to use the traditional I/O path on that handle until all data sections and cache maps are torn down, so filters have got to close that file in order for BypassIO to resume.

* If a BypassIO-enabled file is marked sparse, all BypassIO operations start using the traditional I/O path.

* Defragging a BypassIO-enabled file causes all BypassIO operations to use the traditional I/O path. Once the defragging is completed, the system will switch back to the BypassIO path on that handle.

## What minifilters need to do to support BypassIO

Starting in WIN_COBALT, filter developers should add **SUPPORTED_FS_FEATURES_BYPASS_IO** to **SupportedFeatures** in your driver's .INF or MANIFEST files. (You can type ```fltmc instances``` in an elevated command prompt to see "SprtFtrs" values for all active filters.)

> [!NOTE]
> A filter that can never support BypassIO should still add **SUPPORTED_FS_FEATURES_BYPASS_IO** to its **SupportedFeatures** state, and then veto appropriately inside the filter, specifying the reason.

Minifilters that do not filter IRP_MJ_READ or IRP_MJ_WRITE are automatically opted in to BypassIO support.

The **FS_BPIO_OP_ENABLE** and **FS_BPIO_OP_QUERY** operations will fail on that stack if there is an attached minifilter that has not opted in.

Minifilters are encouraged to minimize vetoing BypassIO as much as possible.

### Impacts when a minifilter does not support BypassIO

If a minifilter attaches to a volume on which BypassIO is enabled, but that minifilter has not updated its **SupportedFeatures** setting to include **SUPPORTED_FS_FEATURES_BYPASS_IO**, :

* All BypassIO operations on that volume are immediately blocked, falling back to the traditional I/O path, resulting in degraded game performance.

### How to determine whether BypassIO is working

An *fsutil* command has been added that issues an **FSCTL_MANAGE_BYPASS_IO** specifying the **FS_BPIO_OP_QUERY** operation. The displayed results identify the first driver that is preventing BypassIO and the reason why.

``` command line
fsutil bypassIo state <path>
```

Where <path> can be a volume, a directory, or a specific filename.

For example, say the WOF minifilter has not opted in to BypassIO:

> fsutil bypassIo state c:\
BypassIo on "c:\" is not currently supported.
  Status: 506 (At least one minifilter does not support bypass IO)
  Driver: wof.sys
  Reason: The specified minifilter does not support bypass IO.


### NTFS-specific behavior

BypassIO can be enabled on an NTFS resident file; however, the file will take the traditional I/O path as long as it is resident. If a write occurs to the file such that it goes non-resident, the system will switch to use the BypassIO path.

NTFS compression cannot be enabled on a BypassIO active file.

NTFS encryption can be enabled on a BypassIO active file. BypassIO will be paused.

BypassIO has no impact on offload read/write operations.


## IOCTL_STORAGE_MANAGE_BYPASS_IO implementation details

The file system (NTFS) generates a **IOCTL_STORAGE_MANAGE_BYPASS_IO** control code in response to a generated **FSCTL_MANAGE_BYPASS_IO** as needed.

Input to **IOCTL_STORAGE_MANAGE_BYPASS_IO** is similar to its **FSCTL_MANAGE_BYPASS_IO** counterpart, but only supports BypassIO enabling, disabling, and querying.

BPIO_INPUT {
  ULONG Version;
  ULONG Size;
  BPIO_OPERATIONS Operation;
  BPIO_INFLAGS InFlags
} BPIO_INPUT

typedef enum _BPIO_OPERATIONS {
  BPIO_OP_ENABLE = 1,
  BPIO_OP_DISABLE,
  BPIO_OP_QUERY
} BPIO_OPERATIONS;

Output from **IOCTL_STORAGE_MANAGE_BYPASS_IO** is similar to its **FSCTL_MANAGE_BYPASS_IO** counterpart, identifying the failing driver's name and reason, and operation status as to why the driver vetoed BypassIO. The file system will propagate the **IOCTL_STORAGE_MANAGE_BYPASS_IO** output from the volume and storage stacks up to the **FSCTL_MANAGE_BYPASS_IO**.

### IOCTL BPIO_OP_ENABLE operation

Same concept as FSCTL, except for a given volume or device. This is a request to enable BypassIO on the given volume or device.

All drivers in the volume and storage stacks have the opportunity to veto the request. If the driver vetoes, they must provide the following information in the BPIO_RESULTS member of the BPIO_OUTPUT structure:

* Their driver's name
* An NTSTATUS code describing why the driver vetoed BypassIO
* A unique, meaningful string that provides details on why the request was vetoed. This string is for diagnostic purposes. It needs to be searchable, so should not be localized.


### IOCTL BPIO_OP_ENABLE

Only file systems send this IOCTL operation. The file system maintains a per-volume count of how many files have BypassIO currently enabled. This IOCTL operation is sent only when this count transitions from zero to one.

Even if a volume or storage stack driver vetoes BypassIO, the file system stack can continue to do BypassIO. This is because if someone has vetoed BypassIO on the volume stack, the file system can still bypass filters.

### IOCTL BPIO_OP_DISABLE operation

Only file systems send this IOCTL operation. It is a request to disable BypassIO for the given volume or device. The file system sends this operation when the last BypassIO-enabled file is disabled or closed (its per-volume count transitions from one to zero).

This operation should not be failed.

## IOCTL BPIO_OP_QUERY operation

Only file systems send this IOCTL operation. It is sent to determine whether BypassIO is supported on a given volume or device without actually enabling it.

Drivers should process this IOCTL similar to the BPIO_OP_ENABLE operation, vetoing as appropriate and returning the same diagnostic information.


## What volume and storage stack drivers need to do to support BypassIO

Starting in Windows 11, storage driver developers need to update their driver's .INF or MANIFEST files to add the **StorageSupportedFeatures** infrastructure with **STORAGE_SUPPORTED_FEATURES_BYPASS_IO** for BypassIO as follows:

* Define a "Parameters" key under your Service definition
* Add a DWORD value named "**StorageSupportedFeatures**"

The driver then processes IOCTL_STORAGE_MANAGE_BYPASS_IO as needed. The **FS_BPIO_OP_QUERY** operation will fail if there is a volume storage stack driver that has not opted in. If the driver can never support BypassIO, add the **StorageSupportedFeatures** state to the INF and then veto appropriately inside the driver, specifying the reason.


### BACK TO FSCTL
### FS_BPIO_OP_VOLUME_STACK_PAUSE operation

If a volume stack driver previously allowed BypassIO to be enabled on that volume, and now needs to stop BypassIO due to some external request, the driver should:

* send FSCTL with this operation to the top of the volume stack to notify the file system to stop doing BypassIO on this volume's volume and storage stacks. The file system will drain all active BypassIO operations from this volume and then return. The volume stack driver can then process the external request.

This operation can be sent multiple times to the same volume. It can sent even if there are no BypassIO-enabled files on the volume.

Note that BypassIO will continue to operate on the file system stack.

#### PAUSE example

Say that Volsnap allowed BypassIO to be enabled on a volume that had no active volume snapshots. Now, a request has been made to create a volume snapshot. Before proceeding, Volsnap does the following:

* Sends the FSCTL FS_BPIO_OP_VOLUME_STACK_PAUSE operation to the top of the stack requesting that BypassIO be disabled on the volume stack. It does this each time a new snapshot is created. Upon successful return, BypassIO is now disabled and drained on the given volume
* Processes the snapshot creation request

Volsnap must veto all future BPIO_OP_ENABLE and BPIO_OP_QUERY requests on this volume.

### FS_BPIO_OP_VOLUME_STACK_RESUME operation

A volume stack driver sends this FSCTL operation to the file system to resume BypassIO processing on the given volume. It sends this operation when the scenario that caused the driver to send FS_BPIO_OP_VOLUME_STACK_PAUSE is no longer active. This operation can be sent even if BypassIO is not currently enabled or paused.

#### VolSnap example

The volume no longer has any active snapshots. Volsnap will send FS_BPIO_OP_VOLUME_STACK_RESUME only after the last snapshot goes away.


### Add this to which refpages??? 30:38 mark

IO Ring is new way of doing IO within IO Manager

GSOD occurred when filters create their own FILE_OBJECT without initializing the IrpList field in that FileObject. Io Manager now looks at a FileObject's IrpList when a file handle is closed (and the handle count reaches zero). IrpList field in FileObject must be initialized using **InitializeListHead**. IO Manager mitigates to detect scenario where initialization hasn't been done and prevent the crash, but filters should be updated to ensure that all fields are properly initialized when creating their own FileObject.





Bypass IO:
	• A new optimized IO path for reading files
	• Requested on a per-handle basis via new FSCTL_MANAGE_BYPASS_IO
		○ IOCTL_STORAGE_MANAGE_BYPASS_IO is also part of this new infrastructure
			§ Sent by FS to the volume/storage stacks

	• Affects the way AV filters operate on Windows
Why B IO is important to AVs
	• part of the infrastructure to support DirectStorage on Windows (DX feature)
		○ Bypass IO helps meet the IO demands of loading and running next-gen games on Windows
		○ Without filter support, game performance will be degraded resulting in a poor gaming experience
	• Laying the foundation today for future uses of BypassIO beyond gaming
		○ Get ready now for BypassIO write support
		○ Get ready now for broader application usage
		○ Get ready now for usage on server

Flow for how it works:
	• When an NtReadFile is called on a BypassIO-enabled FileObject:
		○ Instead of going through the normal filter stack, it goes directly to IO Manager -> FS -> NVMe storage driver
			§ All FS filters are skipped
			§ All volume and storage stack filters are skipped

Skip as much of storage stack as possible
here's what to do if you're OK being bypassed, here's what to do if you can't be bypassed (we want them to be OK being bypassed)

Other filters don't care so much

doc 2 ctls, supporting structs etc
Also doc new flag!
Provide guidance on right decisions to make

One FSCTL, but several operations that go through this FSCTL

Filters care about query and enable
Most don't care about other operations

Encryption: don't disable bypass because they think a file will be encrypted; can RESUME instead

Want to prerelease docs!!

Direct Storage - graphics team (Andrew Yeung)


Neal adding a couple more operations to FSCTL; otherwise stable

Document: FltMgr section is up to date; other part needs to be updated by Darwin
			
Set state so that you veto new requests probably even before you send the pause down so that FS can handle pause correctly.

Resume:

When Bypass is enabled on a given file handle

Bypassing cached IO doesn't make much sense

Bypass IO will be disabled on the filter stack unless filter has set supported_fs_features_bypass_io
Do this in an INF file

fltmc instances

IOCTL_STORAGE_MANAGE_BYPASS_IO
has input and output structures

Volume and storage stack has query

Ask of filter devs:
Update your most recent version and a few versions back

Bypass IO is for gaming optimization
Goal is to minimize # of times that Bypass IO is veto'd

New Feature in windows: IoRing
new and enhanced version to do IO in user mode (avoid transitions to KM)

BYpass currently only supports read (oct 2021 release); future version will support write

When we add future write support, how to handle that with supported feature flag? Will likely add a 2nd flag

can we determine if a file has been modified by some other handle at the time of create relative to the previous create op?

Next release is targeted at new gaming hardware (PCs)
